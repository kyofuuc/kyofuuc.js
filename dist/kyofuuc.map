{"version":3,"file":"kyofuuc.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;;;;ACTA,6EAAyC;;;;;;;;;;;;;ACA5B;;AAEb,cAAc,mBAAO,CAAC,gCAAU;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,GAAG;AACZ;AACA,MAAM;AACN;AACA;AACA;AACA,6BAA6B,EAAE,IAAI;AACnC;AACA,+BAA+B,aAAa;AAC5C;AACA;AACA;AACA,qEAAqE;AACrE;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB,qCAAqC;AACrC,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ,sCAAsC;AAC9E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,OAAO;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC1Ia;;AAEb;AACA;;AAEA;;;;;;;;;;;;;ACLa;;AAEb,cAAc,mBAAO,CAAC,gCAAU;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,OAAO;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AClFa;;AAEb,cAAc,mBAAO,CAAC,gCAAU;;AAEhC;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC5Ea;;AAEb,cAAc,mBAAO,CAAC,gCAAU;AAChC,oCAAoC,mBAAO,CAAC,yFAA+B;;AAE3E;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AClBA;AACA,qBAAqB,mBAAO,CAAC,uEAAsB;AACnD,wBAAwB,mBAAO,CAAC,6EAAyB;AACzD;AACA,2BAA2B,mBAAO,CAAC,mFAA4B;AAC/D,8BAA8B,mBAAO,CAAC,yFAA+B;AACrE,gCAAgC,mBAAO,CAAC,6FAAiC;AACzE;;;;;;;;;;;;;ACPa;;AAEb,cAAc,mBAAO,CAAC,mCAAa;AACnC,yBAAyB,0GAAoD;;AAE7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,IAAI;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;;;;;;;;;;;;AC9KA,oBAAoB,mBAAO,CAAC,4DAAkB;AAC9C,qBAAqB,mBAAO,CAAC,kEAAqB;AAClD,sBAAsB,mBAAO,CAAC,mEAAsB;;AAEpD;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACRa;;AAEb,cAAc,mBAAO,CAAC,mCAAa;AACnC,oBAAoB,qGAA+C;;AAEnE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;;ACnBa;;AAEb,cAAc,mBAAO,CAAC,gCAAU;;AAEhC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,oCAAoC,MAAM;AAC1C;AACA,iBAAiB,QAAQ,KAAK,QAAQ;AACtC;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,wCAAwC,MAAM;AAC9C,6BAA6B,oBAAoB;AACjD;AACA,CAAC;;AAED;;;;;;;;;;;;;ACzDa;;AAEb,cAAc,mBAAO,CAAC,gCAAU;AAChC,sBAAsB,mBAAO,CAAC,oDAAiB;AAC/C,oBAAoB,mBAAO,CAAC,gDAAe;AAC3C;AACA,YAAY,mBAAO,CAAC,wGAA8C;AAClE,YAAY,mBAAO,CAAC,sFAAqC;;AAEzD;AACA;AACA;AACA;AACA,2CAA2C,qCAAqC;AAChF;;AAEA;AACA;AACA;AACA;AACA,qCAAqC,qBAAqB;AAC1D,KAAK;AACL,sBAAsB,qCAAqC;AAC3D;AACA;;AAEA;AACA,sEAAsE,qCAAqC;AAC3G;AACA,6CAA6C,mBAAmB;AAChE,mCAAmC,eAAe;AAClD,yBAAyB,eAAe;AACxC;AACA;AACA,6BAA6B,qCAAqC;AAClE,MAAM;AACN,0BAA0B,qCAAqC;AAC/D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC/Ea;;AAEb,cAAc,mBAAO,CAAC,gCAAU;AAChC,iBAAiB,mBAAO,CAAC,sDAAqB;AAC9C,sBAAsB,mBAAO,CAAC,oDAAiB;AAC/C,uBAAuB,mBAAO,CAAC,sDAAkB;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;;;;;;;;;;;;;;AC3Fa;;AAEb,cAAc,mBAAO,CAAC,gCAAU;AAChC,iBAAiB,mBAAO,CAAC,sDAAqB;AAC9C,sBAAsB,mBAAO,CAAC,oDAAiB;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE,IAAI,UAAU,EAAE;;AAElB;AACA;AACA;AACA,EAAE,IAAI,UAAU;;AAEhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,IAAI,UAAU;;AAEhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,IAAI,oBAAoB;;AAE1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,EAAE,IAAI,UAAU;AAChB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC3LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACPa;;AAEb,cAAc,mBAAO,CAAC,gCAAU;AAChC,gBAAgB,mBAAO,CAAC,iEAAyB;AACjD;;AAEA;;AAEA;AACA;AACA;AACA,cAAc,mBAAO,CAAC,8EAAiC;AACvD,GAAG;AACH,cAAc,mBAAO,CAAC,+EAAkC;AACxD;AACA;AACA;;AAEA;AACA,iBAAiB,mBAAO,CAAC,wEAA8B;AACvD;AACA;;AAEA;AACA;AACA;AACA,uCAAuC,iBAAiB;AACxD,yCAAyC,iBAAiB;AAC1D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1EA,oBAAoB,mBAAO,CAAC,qDAAoB;AAChD,kBAAkB,mBAAO,CAAC,iDAAkB;AAC5C,sBAAsB,mBAAO,CAAC,yDAAsB;AACpD,uBAAuB,mBAAO,CAAC,2DAAuB;AACtD,mBAAmB,mBAAO,CAAC,qDAAoB;AAC/C,sBAAsB,mBAAO,CAAC,2DAAuB;AACrD,iBAAiB,mBAAO,CAAC,qDAAoB;AAC7C,cAAc,mBAAO,CAAC,+BAAS;;AAE/B;AACA,mCAAmC;AACnC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yBAAsB;;;;;;;;;;;;;ACvDT;;AAEb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,OAAO;AACzC;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,wBAAwB,oBAAoB,GAAG,oBAAoB;AACnE,IAAI;AACJ;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,IAAI;AACJ;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ,uCAAuC;AAC/C,QAAQ,uCAAuC;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;UC7dA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;UEtBA;UACA;UACA;UACA","sources":["webpack://ffs/webpack/universalModuleDefinition","webpack://ffs/./index.js","webpack://ffs/./lib/cachemanagers/CookieFFSCacheManager.js","webpack://ffs/./lib/cachemanagers/KeyvRedisFFSCacheManager.js","webpack://ffs/./lib/cachemanagers/LocalStorageFFSCacheManager.js","webpack://ffs/./lib/cachemanagers/MapFFSCacheManager.js","webpack://ffs/./lib/cachemanagers/SessionStorageFFSCacheManager.js","webpack://ffs/./lib/cachemanagers/index.js","webpack://ffs/./lib/connectors/http/xhrConnector.js","webpack://ffs/./lib/connectors/index.js","webpack://ffs/./lib/connectors/ws/wsConnector.js","webpack://ffs/./lib/core/FuInterceptor.js","webpack://ffs/./lib/core/FuQueueManager.js","webpack://ffs/./lib/core/KyofuucHttp.js","webpack://ffs/./lib/core/KyofuucWS.js","webpack://ffs/./lib/helpers/browser_classes.js","webpack://ffs/./lib/helpers/defaults.js","webpack://ffs/./lib/kyofuuc.js","webpack://ffs/./lib/utils.js","webpack://ffs/webpack/bootstrap","webpack://ffs/webpack/before-startup","webpack://ffs/webpack/startup","webpack://ffs/webpack/after-startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ffs\"] = factory();\n\telse\n\t\troot[\"ffs\"] = factory();\n})(this, () => {\nreturn ","\nmodule.exports = require('./lib/kyofuuc');\n","\n'use strict';\n\nconst utils = require(\"../utils\");\n\n// example 2 days = ((2) *24*60*60*1000)\nfunction ffCMSetCookie(cookiesImpl, name, value, expiryInMilliSeconds, options) {\n    let expires = \"\";\n    if (expiryInMilliSeconds) {\n        let date = new Date();\n        date.setTime(date.getTime() + (expiryInMilliSeconds));\n        expires = \"; expires=\" + date.toUTCString();\n    }\n    if (cookiesImpl) {\n        /*cookiesImpl.setItem(name, JSON.stringify({\n            name,\n            expires,\n            value,\n            path: \"/\"\n        }));*/\n        cookiesImpl.setItem(name, value);\n    } else {\n\t\tlet extraCookieOptions = \"\";\n\t\tif (options) {\n\t\t\tfor (let key in options) {\n\t\t\t\textraCookieOptions += `; ${key}`;\n\t\t\t\tif (options[key] !== true) {\n\t\t\t\t\textraCookieOptions += `=${options[key]}`;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        document.cookie = name + \"=\" + (value || \"\")  + expires + \"; path=/\" + extraCookieOptions;\n    }\n}\n\nfunction ffCMGetCookie(cookiesImpl, name) {\n    let nameWithEQ = name + \"=\";\n    if (cookiesImpl) { return cookiesImpl.getItem(name) }\n    let ca = document.cookie.split(';');\n    for(let index = 0; index < ca.length; index++) {\n        let c = ca[index];\n        while (c.charAt(0)==' ') c = c.substring(1, c.length);\n        if (c.indexOf(nameWithEQ) == 0) return c.substring(nameWithEQ.length, c.length);\n    }\n    return null;\n}\n\nfunction ffCMInvalidateCookie(cookiesImpl, name) {   \n    if (cookiesImpl) {\n        cookiesImpl.removeItem(name);\n        return;\n    }\n    document.cookie = name +'=; Path=/; Expires=Thu, 01 Jan 1970 00:00:01 GMT;';\n}\n\n// expires in 24 hours by default, if it borswer cookie manager and not a custom implementation\n// the cookie Secure attribute is set to true if undefined\nfunction CookieFFSCacheManager(options) {\n    this.interceptorIds = [];\n\tthis.interceptor = undefined;\n    if (utils.isObject(options) && options.encryptor) {\n\t\tthis.encryptor = options.encryptor;\n\t\tthis.decryptor = options.decryptor;\n\t\tthis.cookiesImpl = options.bucket;\n        this.expiryInMilliSeconds = options.expiryInMilliSeconds || ((1) *24*60*60*1000); \n\t} else {\n\t\tthis.cookiesImpl = options;\n        this.expiryInMilliSeconds = ((1) *24*60*60*1000);\n\t}\n}\n\nCookieFFSCacheManager.prototype.registerInterceptors = function registerInterceptors(interceptor) {\n    if (!interceptor) return;\n\tconst instance = this;\n\tthis.interceptor = interceptor;\n    let cookiesImpl = this.cookiesImpl;\n    let expiryInMilliSeconds = this.expiryInMilliSeconds;\n    const preInterceptorId = interceptor.registerPreRequest(function cookieFFSCMPReqInterceptor(options, config) {\n        if (!config.cache) return;\n        const cachedValue = options.get.call(instance, config);\n\t\tif (cachedValue !== undefined) {\n\t\t\tif (config.refreshCache) {\n\t\t\t\tffCMInvalidateCookie(instance.cookiesImpl, config.key);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tFROM_FFS_CACHE_MANAGER_INTERCEPTOR: true,\n\t\t\t\tkey: config.key,\n\t\t\t\tvalue: cachedValue\n\t\t\t};\n\t\t}\n    }, {\n        decryptor: this.decryptor,\n\t\tget: this.get\n    });\n    this.interceptorIds.push(preInterceptorId);\n\n    const postInterceptorId = interceptor.registerPostResponse(function cookieFFSCMPResInterceptor(options, config, response) {\n        if (!config.cache) return;\n        if (response) {\n            options.set.call(instance, config, response);\n        }\n    }, {\n        encryptor: this.encryptor,\n\t\tset: this.set\n    });\n    this.interceptorIds.push(postInterceptorId);\n}\n\nCookieFFSCacheManager.prototype.unRegisterInterceptors = function unRegisterInterceptors(interceptor) {\n    for (let interceptorId of this.interceptorIds) {\n        interceptor.unRegister(interceptorId);\n    }\n}\n\nCookieFFSCacheManager.prototype.get = function getFromCFFSCM(config) {\n\tconfig.key = utils.buildCacheKey(config);\n\tlet cachedValue = ffCMGetCookie(this.cookiesImpl, config.key);\n\tif (cachedValue === null || cachedValue === undefined) return cachedValue;\n\tcachedValue = (typeof this.encryptor === 'function') ? this.decryptor(cachedValue, config) : cachedValue;\n\tif (cachedValue !== undefined) {\n\t\treturn JSON.parse(cachedValue).value;\n\t}\n}\n\nCookieFFSCacheManager.prototype.set = function setForCFFSCM(config, value) {\n\tconfig.key = utils.buildCacheKey(config);\n\tvalue = JSON.safeStringify({ value });\n\tlet encryptedValue = (typeof this.encryptor === 'function') ? this.encryptor(value, config) : value;\n\tlet cacheOptions = config.cacheOptions || {};\n\tif (cacheOptions.Secure === undefined) cacheOptions.Secure = true;\n\tffCMSetCookie(this.cookiesImpl, config.key, encryptedValue, this.expiryInMilliSeconds, cacheOptions);\n}\n\nCookieFFSCacheManager.prototype.remove = function removeFromCFFSCM(config) {\n\tconfig.key = utils.buildCacheKey(config);\n\tffCMInvalidateCookie(this.cookiesImpl, config.key);\n}\n\nmodule.exports = CookieFFSCacheManager;\n","\n'use strict';\n\nfunction KeyvRedisFFSCacheManager(interceptor) {\n}\n\nmodule.exports = KeyvRedisFFSCacheManager;\n","\n'use strict';\n\nconst utils = require(\"../utils\");\n\nfunction LocalStorageFFSCacheManager(options) {\n\tthis.interceptorIds = [];\n\tthis.interceptor = undefined;\n\tif (utils.isObject(options) && options.encryptor) {\n\t\tthis.encryptor = options.encryptor;\n\t\tthis.decryptor = options.decryptor;\n\t\tthis.localStorageImpl = options.bucket;\n\t} else {\n\t\tthis.localStorageImpl = options;\n\t}\n\tthis.localStorageImpl = this.localStorageImpl || localStorage;\n}\n\nLocalStorageFFSCacheManager.prototype.registerInterceptors = function registerInterceptors(interceptor) {\n\tif (!interceptor) return;\n\tconst instance = this;\n\tthis.interceptor = interceptor;\n\tconst localStorageImpl = this.localStorageImpl;\n\tconst preInterceptorId = interceptor.registerPreRequest(function lsFFSCMPReqInterceptor(options, config) {\n\t\tif (!config.cache) return;\n\t\tconst cachedValue = options.get.call(instance, config);\n\t\tif (cachedValue !== undefined) {\n\t\t\tif (config.refreshCache) {\n\t\t\t\tlocalStorageImpl.removeItem(config.key);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tFROM_FFS_CACHE_MANAGER_INTERCEPTOR: true,\n\t\t\t\tkey: config.key,\n\t\t\t\tvalue: cachedValue\n\t\t\t};\n\t\t}\n\t}, {\n\t\tdecryptor: this.decryptor,\n\t\tget: this.get\n\t});\n\tthis.interceptorIds.push(preInterceptorId);\n\n\tconst postInterceptorId = interceptor.registerPostResponse(function lsFFSCMPResInterceptor(options, config, response) {\n\t\tif (!config.cache) return;\n\t\tif (response) {\n\t\t\toptions.set.call(instance, config, response);\n\t\t}\n\t}, {\n\t\tencryptor: this.encryptor,\n\t\tset: this.set\n\t});\n\tthis.interceptorIds.push(postInterceptorId);\n}\n\nLocalStorageFFSCacheManager.prototype.unRegisterInterceptors = function unRegisterInterceptors(interceptor) {\n\tfor (let interceptorId of this.interceptorIds) {\n\t\tinterceptor.unRegister(interceptorId);\n\t}\n}\n\nLocalStorageFFSCacheManager.prototype.get = function getFromLSFFSCM(config) {\n\tconfig.key = utils.buildCacheKey(config);\n\tlet cachedValue = this.localStorageImpl.getItem(config.key);\n\tif (cachedValue === null || cachedValue === undefined) return cachedValue;\n\tcachedValue = (typeof this.encryptor === 'function') ? this.decryptor(cachedValue, config) : cachedValue;\n\tif (cachedValue !== undefined) {\n\t\treturn JSON.parse(cachedValue).value;\n\t}\n}\n\nLocalStorageFFSCacheManager.prototype.set = function setForLSFFSCM(config, value) {\n\tconfig.key = utils.buildCacheKey(config);\n\tvalue = JSON.safeStringify({ value });\n\tlet encryptedValue = (typeof this.encryptor === 'function') ? this.encryptor(value, config) : value;\n\tthis.localStorageImpl.setItem(config.key, encryptedValue);\n}\n\nLocalStorageFFSCacheManager.prototype.remove = function removeFromLSFFSCM(config) {\n\tconfig.key = utils.buildCacheKey(config);\n\tthis.localStorageImpl.removeItem(config.key);\n}\n\nmodule.exports = LocalStorageFFSCacheManager;\n","\n'use strict';\n\nconst utils = require(\"../utils\");\n\nfunction MapFFSCacheManager(options) {\n\tthis.interceptor = undefined;\n\tthis.interceptorIds = [];\n\tif (utils.isObject(options) && options.bucket) {\n\t\tthis.bucket = options.bucket;\n\t} else {\n\t\tthis.bucket = options || {};\n\t}\n}\n\nMapFFSCacheManager.prototype.registerInterceptors = function registerInterceptors(interceptor) {\n\tif (!interceptor) return;\n\tconst instance = this;\n\tthis.interceptor = interceptor;\n\tconst preInterceptorId = interceptor.registerPreRequest(function mFFSCMPReqInterceptor(options, config) {\n\t\tif (!config.cache) return;\n\t\tconst cachedValue = options.get.call(instance, config)\n\t\tif (cachedValue !== undefined) {\n\t\t\tif (config.refreshCache) {\n\t\t\t\tdelete options.bucket[config.key];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tFROM_FFS_CACHE_MANAGER_INTERCEPTOR: true,\n\t\t\t\tkey: config.key,\n\t\t\t\tvalue: cachedValue\n\t\t\t};\n\t\t}\n\t}, {\n\t\tbucket: this.bucket,\n\t\tget: this.get\n\t});\n\tthis.interceptorIds.push(preInterceptorId);\n\t\n\tconst postInterceptorId = interceptor.registerPostResponse(function mFFSCMPResInterceptor(options, config, response) {\n\t\tif (!config.cache) return;\n\t\tif (response) {\n\t\t\toptions.set.call(instance, config, response);\n\t\t}\n\t}, {\n\t\tbucket: this.bucket,\n\t\tset: this.set\n\t});\n\tthis.interceptorIds.push(postInterceptorId);\n}\n\nMapFFSCacheManager.prototype.unRegisterInterceptors = function unRegisterInterceptors(interceptor) {\n\tfor (let interceptorId of this.interceptorIds) {\n\t\tinterceptor.unRegister(interceptorId);\n\t}\n}\n\nMapFFSCacheManager.prototype.get = function getFromMFFSCM(config) {\n\tconfig.key = utils.buildCacheKey(config);\n\tconst cachedValue = this.bucket[config.key];\n\tif (cachedValue !== undefined) {\n\t\treturn JSON.parse(cachedValue).value;\n\t}\n}\n\nMapFFSCacheManager.prototype.set = function setForMFFSCM(config, value) {\n\tconfig.key = utils.buildCacheKey(config);\n\tthis.bucket[config.key] = JSON.safeStringify({\n\t\tvalue\n\t});\n}\n\nMapFFSCacheManager.prototype.remove = function removeFromMFFSCM(config) {\n\tconfig.key = utils.buildCacheKey(config);\n\tdelete this.bucket[config.key];\n}\n\nmodule.exports = MapFFSCacheManager;\n","\n'use strict';\n\nconst utils = require(\"../utils\");\nconst LocalStorageFFSCacheManager = require('./LocalStorageFFSCacheManager');\n\nfunction SessionStorageFFSCacheManager(options) {\n\tlet forwardOptions = {};\n\tif (utils.isObject(options) && forwardOptions.encryptor) {\n\t\tforwardOptions.encryptor = options.encryptor;\n\t\tforwardOptions.decryptor = options.decryptor;\n\t\tforwardOptions.bucket = options.bucket;\n\t} else {\n\t\tforwardOptions.bucket = options;\n\t}\n\tforwardOptions.bucket = forwardOptions.bucket || sessionStorage;\n\treturn new LocalStorageFFSCacheManager(options);\n}\n\nmodule.exports = SessionStorageFFSCacheManager;\n","\nmodule.exports = {\n\tMapFFSCacheManager: require(\"./MapFFSCacheManager\"),\n\tCookieFFSCacheManager: require(\"./CookieFFSCacheManager\"),\n\t//KonfigerFFSCacheManager: require(\"./KonfigerFFSCacheManager\"),\n\tKeyvRedisFFSCacheManager: require(\"./KeyvRedisFFSCacheManager\"),\n\tLocalStorageFFSCacheManager: require(\"./LocalStorageFFSCacheManager\"),\n\tSessionStorageFFSCacheManager: require(\"./SessionStorageFFSCacheManager\"),\n};\n","\n'use strict';\n\nconst utils = require('../../utils');\nconst KFXMLHttpRequest = require(\"../../helpers/node_classes\").XMLHttpRequest;\n\nfunction xhrConnector(config, httpInterceptor) {\n\treturn new Promise(function makeRequest(resolvePromise, rejectPromise) {\n\t\tlet reqData = config.data || null;\n\t\tlet reqHeaders = config.headers || {};\n\t\tlet headerNames = Object.keys(reqHeaders).reduce((acc, header) => {\n\t\t\tacc[header.toLowerCase()] = header;\n\t\t\treturn acc;\n\t\t}, {});\n\t\tlet responseType = config.responseType;\n\t\thttpInterceptor = httpInterceptor || (config.cache && config.cache.interceptor\n\t\t\t? config.cache.interceptor \n\t\t\t: httpInterceptor);\n\n\t\tif (utils.isFormData(reqData) && headerNames['content-type']) {\n\t\t\tdelete reqHeaders['content-type'];\n\t\t} else if ((utils.isPlainObject(reqData) || utils.isObject(reqData) || utils.isArray(reqData)) && !headerNames['content-type']) {\n\t\t\treqHeaders['Content-Type'] = \"application/json\";\n\t\t}\n\t\tconst preRequestResults = utils\n\t\t\t.invokeForEachInterceptorType(httpInterceptor, \"HTTP_PRE_REQUEST\", config)\n\t\t\t.filter(preRequestResult => preRequestResult.FROM_FFS_CACHE_MANAGER_INTERCEPTOR === true);\n\t\tif (preRequestResults.length > 0 && !config.refreshCache) {\n\t\t\tpreRequestResults[0].value.isFromCache = true;\n\t\t\tresolvePromise(preRequestResults[0].value);\n\t\t\treturn;\n\t\t}\n\t\tlet req = new KFXMLHttpRequest();\n\t\tif (config.auth) {\n\t\t\tlet username = config.auth.username || '';\n\t\t\tlet password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';\n\t\t\treqHeaders.Authorization = 'Basic ' + utils.toBase64(username + ':' + password);\n\t\t}\n\t\tlet fullPath = utils.buildFullURLPath(config.baseURL, config.url);\n    \treq.open((config.method || \"get\").toUpperCase(), utils.buildURL(fullPath, config.params, config.paramsSerializer), true);\n\t\t\n\t\tfunction onloadend() {\n\t\t\tif (!req) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlet responseHeaders = 'getAllResponseHeaders' in req ? utils.parseHeaders(req.getAllResponseHeaders()) : null;\n\t\t\tlet responseData = !responseType || responseType === 'text' ||  responseType === 'json' \n\t\t\t\t? req.responseText \n\t\t\t\t: req.response;\n\t\t\tlet response = {\n\t\t\t\tstatus: req.status,\n\t\t\t\tstatusText: req.statusText,\n\t\t\t\theaders: responseHeaders,\n\t\t\t\tconfig: config,\n\t\t\t\trequest: req,\n\t\t\t\tisFromCache: false\n\t\t\t};\n\t\t\tutils.invokeForEachInterceptorType(httpInterceptor, \"HTTP_PRE_RESPONSE\", config, response);\n\t\t\tresponse.body = responseData;\n\t\t\tif (req.status != 204 && config.responseType && config.responseType.toLowerCase().indexOf(\"json\") != -1) {\n\t\t\t\ttry {\n\t\t\t\t\tresponse.data = JSON.parse(response.body);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tresponse.data = response.body;\n\t\t\t\t\trejectPromise(utils.kyofuucError(\n\t\t\t\t\t\t'error trying to parse response body to data JSON',\n\t\t\t\t\t\tconfig,\n\t\t\t\t\t\tutils.ERROR_CODES.ERR_PROCESSING_BODY_AS_JSON_DATA,\n\t\t\t\t\t\tresponse.request,\n\t\t\t\t\t\tresponse\n\t\t\t\t\t));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresponse.data = response.body;\n\t\t\t}\n\t\t\tutils.invokeForEachInterceptorType(httpInterceptor, \"HTTP_POST_RESPONSE\", config, response);\n\t\t\tutils.resolveResponse(response, resolvePromise, rejectPromise);\n\t\t\treq = null;\n\t\t}\n\t\tif ('onloadend' in req) {\n\t\t\treq.onloadend = onloadend;\n\t\t} else {\n\t\t\treq.onreadystatechange = function handleLoad() {\n\t\t\t\tif (!req || req.readyState !== 4) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (req.status === 0 && !(req.responseURL && req.responseURL.indexOf('file:') === 0)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tsetTimeout(onloadend);\n\t\t\t};\n\t\t}\n\t\treq.onerror = function handleError() {\n\t\t\tif (config.retry) {\n\t\t\t\tconfig.putInRetryQueue(config);\n\t\t\t\tlet response = {\n\t\t\t\t\tstatus: 109,\n\t\t\t\t\tstatusText: \"Awaiting Retry\",\n\t\t\t\t\theaders: [],\n\t\t\t\t\tconfig: config,\n\t\t\t\t\trequest: req,\n\t\t\t\t\tisFromCache: false\n\t\t\t\t};\n\t\t\t\tutils.resolveResponse(response, resolvePromise, rejectPromise);\n\t\t\t\treturn;\n\t\t\t};\n\t\t\trejectPromise(utils.kyofuucError(\n\t\t\t\t'Network error',\n\t\t\t\tconfig,\n\t\t\t\tutils.ERROR_CODES.NETWORK_ERROR,\n\t\t\t\treq\n\t\t\t));\n\t\t\treq = null;\n\t\t};\n\t\treq.onabort = function handleAbort() {\n\t\t\tif (!req) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\trejectPromise(utils.kyofuucError(\n\t\t\t\t'error request aborted',\n\t\t\t\tconfig,\n\t\t\t\tutils.ERROR_CODES.REQUEST_ABORTED,\n\t\t\t\treq\n\t\t\t));\n\t\t\treq = null;\n\t\t};\n\t\treq.ontimeout = function handleTimeout() {\n\t\t\tlet timeoutErrorMessage = config.timeout \n\t\t\t\t? 'timeout of ' + config.timeout + 'ms exceeded' \n\t\t\t\t: 'timeout exceeded';\n\t\t\tif (config.timeoutErrorMessage) {\n\t\t\t\ttimeoutErrorMessage = config.timeoutErrorMessage;\n\t\t\t}\n\t\t\trejectPromise(utils.kyofuucError(\n\t\t\t\ttimeoutErrorMessage,\n\t\t\t\tconfig,\n\t\t\t\tutils.ERROR_CODES.TIMEOUT_ERROR,\n\t\t\t\treq\n\t\t\t));\n\t\t\treq = null;\n\t\t};\n\t\tif ('setRequestHeader' in req) {\n\t\t\tutils.forEach(reqHeaders, function setRequestHeader(val, key) {\n\t\t\t\tif (typeof reqData === 'undefined' && key.toLowerCase() === 'content-type') {\n\t\t\t\t\tdelete reqHeaders[key];\n\t\t\t\t} else {\n\t\t\t\t\treq.setRequestHeader(key, val);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tif (utils.envIsStandardBrowser()) {\n\t\t\tlet xsrfValue = (config.withCredentials || utils.isURLSameOrigin(fullPath)) && config.xsrfCookieName \n\t\t\t\t? cookies.read(config.xsrfCookieName) \n\t\t\t\t: undefined;\t\t\n\t\t\tif (xsrfValue) {\n\t\t\t\treqHeaders[config.xsrfHeaderName] = xsrfValue;\n\t\t\t}\n\t\t}\n\t\tif (!utils.isUndefined(config.withCredentials)) {\n\t\t\treq.withCredentials = !!config.withCredentials;\n\t\t}\n\t\tif (responseType && !(responseType.toLowerCase().indexOf(\"json\") != -1)) {\n\t\t\treq.responseType = config.responseType;\n\t\t}\n\t\tif (typeof config.onDownloadProgress === 'function') {\n\t\t\treq.addEventListener('progress', config.onDownloadProgress);\n\t\t}\n\t\tif (typeof config.onUploadProgress === 'function' && req.upload) {\n\t\t\treq.upload.addEventListener('progress', config.onUploadProgress);\n\t\t}\n\t\treq.send(JSON.stringify(reqData));\n\t\tutils.invokeForEachInterceptorType(httpInterceptor, \"HTTP_POST_REQUEST\", config);\n\t});\n}\n\nmodule.exports = xhrConnector;\n","\nconst wsConnector = require('./ws/wsConnector');\nconst xhrConnector = require('./http/xhrConnector');\nconst httpConnector = require('./http/httpConnector');\n\nmodule.exports = {\n\twsConnector,\n\txhrConnector,\n\thttpConnector\n};\n","\n'use strict';\n\nconst utils = require('../../utils');\nconst KFWebSocket = require(\"../../helpers/node_classes\").WebSocket;\n\nfunction wsConnector(config, wsInterceptor) {\n\tconst fullPath = utils.buildFullURLPath(config.baseURL, config.url);\n\tconst absoluteUrl = utils.buildURL(fullPath, config.params, config.paramsSerializer);\n\tconst socket = new KFWebSocket(absoluteUrl, config.protocol);\n\n\tsocket.addEventListener('close', (e) => utils.invokeForEachInterceptorType(wsInterceptor, \"WS_CLOSE\", config, e));\n\tsocket.addEventListener('error', (e) => utils.invokeForEachInterceptorType(wsInterceptor, \"WS_ERROR\", config, e));\n\tsocket.addEventListener('message', (e) => utils.invokeForEachInterceptorType(wsInterceptor, \"WS_MESSAGE\", config, e));\n\tsocket.addEventListener('open', (e) => utils.invokeForEachInterceptorType(wsInterceptor, \"WS_OPEN\", config, e));\n\tsocket.implname = \"wsConnector\";\n\n\treturn socket;\n}\n\nmodule.exports = wsConnector;\n","\n'use strict';\n\nconst utils = require('../utils');\n\nfunction FuInterceptor() {\n\tthis.handlers = [];\n}\n\nFuInterceptor.prototype.register = function register(type, cb, options) {\n\tthis.handlers.push({\n\t\ttype,\n\t\tcb,\n\t\toptions\n\t});\n\treturn this.handlers.length-1;\n}\n\nFuInterceptor.prototype.unRegister = function unRegister(id) {\n\tif (this.handlers[id]) {\n\t\tthis.handlers[id] = null;\n\t}\n}\n\nFuInterceptor.prototype.filter = function filter(cond, thisArg) {\n\treturn this.handlers.filter(cond, thisArg);\n}\n\nFuInterceptor.prototype.forEach = function forEach(cb, type) {\n\tutils.forEach(this.handlers, function handlerLoop(handler) {\n\t\tif (handler !== null && (!type || handler.type === type)) {\n\t\t\tcb(handler);\n\t\t}\n\t});\n}\n\n// HTTP_PRE_REQUEST\n// HTTP_POST_REQUEST\n// HTTP_PRE_RESPONSE\n// HTTP_POST_RESPONSE\nutils.forEach(['PreRequest', 'PostRequest', 'PreResponse', 'PostResponse'], function forEachHttpLevel(level) {\n\tFuInterceptor.prototype[`register${level}`] = function (cb, options) {\n\t\tlet type = level.split(\"Re\");\n\t\ttype = `HTTP_${type[0]}_RE${type[1]}`.toUpperCase();\n\t\treturn this.register(type, cb, options);\n\t}\n});\n\n// WS_CLOSE\n// WS_ERROR\n// WS_MESSAGE\n// WS_OPEN\nutils.forEach([ 'Close', 'Error', 'Message', 'Open' , 'StateChange' ], function forEachWSEvent(event) {\n\tFuInterceptor.prototype[`registerOnWS${event}`] = function (cb, options) {\n\t\treturn this.register(`WS_${event.toUpperCase()}`, cb, options);\n\t}\n});\n\nmodule.exports = FuInterceptor;\n","\n'use strict';\n\nconst utils = require('../utils');\nconst FuInterceptor = require('./FuInterceptor');\nconst KyofuucHttp = require('./KyofuucHttp');\nconst defaultRetryCache = utils.presentElseImport(typeof localStorage, \n\t() => new (require('../cachemanagers/LocalStorageFFSCacheManager'))(null, null), \n\t() => new (require('../cachemanagers/MapFFSCacheManager'))());\n\n// This uses the stack data structure not queue, LIFO\nfunction FuQueueManager(cache) {\n    this._cache = cache || defaultRetryCache;\n    this._interceptor = this._cache.interceptor || new FuInterceptor();\n    this._entriesCount = this._cache.get({ key: \"FUQUEUEMANAGER_ENTRIES_COUNT\" }) || 0;\n}\n\nFuQueueManager.prototype.push = function push(object, type) {\n    if (object === undefined) return;\n    if (type && utils.isObject(object)) object.type = type;\n    this._cache.set({\n        key: `FUQUEUEMANAGER_ENTRY_${++this._entriesCount}`\n    }, object);\n    this._cache.set({ key: `FUQUEUEMANAGER_ENTRIES_COUNT` }, this._entriesCount);\n    utils.forEach(utils.getGlobalEvent(utils.GLOBAL_EVENT_NAMES.EVENT_QUEUED), (cb) => cb(object.type, object));\n}\n\nFuQueueManager.prototype.pop = function pop() {\n\tif (this._entriesCount === 0) this._entriesCount = this._cache.get({ key: \"FUQUEUEMANAGER_ENTRIES_COUNT\" }) || 0;\n    if (!this._entriesCount) return;\n    const entryKey = `FUQUEUEMANAGER_ENTRY_${this._entriesCount}`;\n    const data = this._cache.get({ key: entryKey });\n    this._cache.remove({ key: entryKey });\n    this._entriesCount--;\n    if (!this._entriesCount) {\n        this._cache.remove({ key: `FUQUEUEMANAGER_ENTRIES_COUNT` });\n    } else {\n        this._cache.set({ key: `FUQUEUEMANAGER_ENTRIES_COUNT` }, this._entriesCount);\n    }\n    return data;\n}\n\n// use global registered rebuilder function\n// also use te defaults in ffs objects itself if resolvers not present\nfunction rebuildRetryObject(config, ffs) {\n    // if global resolver available, use instewad and return\n    if (config._cacheName !== \"\") {\n        config.cache = ffs.rebuildRetryObjectCache ? ffs.rebuildRetryObjectCache(config) : null;\n        if (!config.cache) {\n            switch (config._cacheName) {\n                case \"MapFFSCacheManager\":\n                    config.cache = new ffs.cachemanagers.MapFFSCacheManager();\n                    break;\n            }\n        }\n    }\n    return config;\n}\n\nFuQueueManager.prototype.retry = function retry(type, ffs) {\n    let entry;\n    while ((entry = this.pop())) {\n        if (entry.type !== type) continue;\n        if (type === FuQueueManager.TYPE.HTTP_REQUEST) {\n            (new ffs.KyofuucHttp()).request(rebuildRetryObject(entry.config, ffs))\n            .then(response => {\n                if (response.status != 109) {\n                    utils.forEach(utils.getGlobalEvent(utils.GLOBAL_EVENT_NAMES.RETRY_SUCCESS), (cb) => cb(type, response));\n                }\n            }).catch(error => {\n                utils.forEach(utils.getGlobalEvent(utils.GLOBAL_EVENT_NAMES.RETRY_FAILED), (cb) => cb(type, response));\n            });\n        }\n    }\n}\n\nFuQueueManager.TYPE = {\n    HTTP_REQUEST: \"KYOFUUC_HTTP_REQUEST\"\n}\n\nmodule.exports = FuQueueManager;\n","\n'use strict';\n\nconst utils = require('../utils');\nconst defaults = require('../helpers/defaults');\nconst FuInterceptor = require('./FuInterceptor');\nconst FuQueueManager = require('./FuQueueManager');\n\nfunction KyofuucHttp(httpBaseConfig) {\n\tthis.httpBaseConfig = httpBaseConfig || {};\n\tthis.httpInterceptor = this.httpBaseConfig.interceptor || new FuInterceptor();\n\tif (this.httpBaseConfig.cache && typeof this.httpBaseConfig.cache.registerInterceptors === 'function') {\n\t\tthis.httpBaseConfig.cache.registerInterceptors(this.httpInterceptor);\n\t}\n}\n\nfunction putInRetryQueue(config) {\n\tconst fuQueueManager = config.fuQueueManager || new FuQueueManager();\n\tconfig._retryCount = !utils.isNumber(config._retryCount) ? 1 : ++config._retryCount;\n\tif (!utils.isNumber(config.maxRetry)) {\n\t\tconfig.maxRetry = defaults.maxReconnectOrRetry;\n\t}\n\tif (config._retryCount > config.maxRetry) {\n\t\tutils.forEach(utils.getGlobalEvent(utils.GLOBAL_EVENT_NAMES.RETRY_MAXED_OUT), (cb) => cb(config));\n\t\treturn;\n\t}\n\tconfig._cacheName = config.cache ? config.cache.constructor.name : \"\";\n\tfuQueueManager.push({\n\t\ttype: \"KYOFUUC_HTTP_REQUEST\",\n\t\tconfig\n\t});\n}\n\nKyofuucHttp.prototype.request = function request(urlOrConfig, config) {\n\tif (typeof urlOrConfig === 'string') {\n\t\tconfig = config || {};\n\t\tconfig.url = urlOrConfig;\n\t} else {\n\t\tconfig = urlOrConfig || {};\n\t}\n\tlet tempCache = config.cache;\n\tconfig = utils.mergeObject(config, this.httpBaseConfig);\n\n\tif (tempCache && tempCache.interceptorIds.length === 0) {\n\t\ttempCache.registerInterceptors(this.httpInterceptor);\n\t}\n\tif (config.retry) {\n\t\tconfig.putInRetryQueue = putInRetryQueue;\n\t}\n\n\tlet promise;\n\tconst connector = (config.connector || defaults.getDefaultHttpConnector());\n\tpromise = connector(config, this.httpInterceptor);\n\tif (tempCache && tempCache.interceptorIds.length > 0) {\n\t\ttempCache.unRegisterInterceptors(this.httpInterceptor);\n\t}\n\treturn promise;\n}\n\nKyofuucHttp.prototype.getUrl = function getUrl(config) {\n\tif (!config.url) {\n\t\tthrow new Error(\"Invalid config url provider\");\n\t}\n\tconfig = utils.mergeObject(config, this.httpBaseConfig);\n\treturn utils.buildURL(config.url, config.params, config.paramsSerializer).replace(/^\\?/, '');\n};\n\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoPayload(method) {\n\tKyofuucHttp.prototype[method] = function (url, config) {\n\t\treturn this.request(utils.mergeObject(config, {\n\t\t\tmethod,\n\t\t\turl,\n\t\t\tdata: (config || {}).data\n\t\t}));\n\t}\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithPayload(method) {\n\tKyofuucHttp.prototype[method] = function (url, data, config) {\n\t\tif (!config) config = {};\n\t\tif (!config.headers) config.headers = {};\n\t\tif (!config.headers[\"accept\"] && !config.headers[\"Accept\"] && !config.headers[\"ACCEPT\"]) {\n\t\t\tconfig.headers[\"Accept\"] = \"application/json, text/plain, */*\";\n\t\t}\n\t\treturn this.request(utils.mergeObject(config, {\n\t\t\tmethod,\n\t\t\turl,\n\t\t\tdata\n\t\t}));\n\t}\n});\n\nmodule.exports = KyofuucHttp;\n\n","\n'use strict';\n\nconst utils = require('../utils');\nconst defaults = require('../helpers/defaults');\nconst FuInterceptor = require('./FuInterceptor');\n\nfunction KyofuucWS(wsConfig) {\n\tthis.state = 0;\n\tthis.protocol = \"\";\n\tthis._reconnectionCount = 0;\n\tthis._nextReconnectionDelay = 0;\n\tthis.lastReconnectionCount = 0;\n\tthis.wsConfig = wsConfig || {};\n\tthis.interceptor = this.wsConfig.interceptor || new FuInterceptor();\n\tthis.eventHooks = {\n\t\t\"onOpen\": [],\n\t\t\"onClose\": [],\n\t\t\"onError\": [],\n\t\t\"onMessage\": [],\n\t\t\"onStateChange\": []\n\t};\n}\n\nKyofuucWS.prototype.reconnect = function reconnect(connector) {\n\tif (this.state != 2 && this.state != 3) {\n\t\tthis.close();\n\t}\n\tif (!connector) connector = (this.wsConfig.connector || defaults.getDefaultWSConnector());\n\tthis.state = 4;\n\tutils.forEach(this.eventHooks.onStateChange, (cb) => cb(this, this.state));\n\tthis.connection = connector(this.wsConfig, this.interceptor);\n}\n\nKyofuucWS.prototype.ws = function ws(urlOrConfig, config) {\n\tconst instance = utils.mergeClasses(new KyofuucWS(), this);\n\tif (typeof urlOrConfig === 'string') {\n\t\tconfig = config || {};\n\t\tconfig.url = urlOrConfig;\n\t} else {\n\t\tconfig = urlOrConfig || {};\n\t}\n\tinstance.wsConfig = utils.mergeObject(config, instance.wsConfig);\n\tconfig = instance.wsConfig;\n\tconst connector = (config.connector || defaults.getDefaultWSConnector());\n\n\t// onStateChange event, not neede\n\t/*instance.interceptor.registerOnWSStateChange((options, config, state) => {\n\t\tutils.forEach(instance.eventHooks.onStateChange, (cb) => cb(instance, state));\n\t}, { instance });*/\n\n\t// onError event\n\tinstance.interceptor.registerOnWSError((options, config, event) => {\n\t\tutils.forEach(instance.eventHooks.onError, (cb) => cb(instance, event));\n\t}, { instance });\n\n\t// onClose event\n\tinstance.interceptor.registerOnWSClose((options, config, event) => {\n\t\tif (instance.state !== 2 && instance.wsConfig.reconnect === true) {\n\t\t\tif (instance.lastReconnectionCount < instance.wsConfig.maxReconnect) {\n\t\t\t\tinstance._reconnectionCount++;\n\t\t\t\tinstance.lastReconnectionCount++;\n\t\t\t\tinstance._nextReconnectionDelay = instance.wsConfig.reconnectIntervalByPower \n\t\t\t\t\t? Math.pow(instance.wsConfig.reconnectInterval, instance._reconnectionCount)\n\t\t\t\t\t: instance.wsConfig.reconnectInterval;\n\t\t\t\tsetTimeout(instance.reconnect.bind(instance, connector), instance._nextReconnectionDelay * 1000);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tinstance.state = event.target.readyState;\n\t\tutils.forEach(instance.eventHooks.onStateChange, (cb) => cb(instance, instance.state));\n\t\tutils.forEach(instance.eventHooks.onClose, (cb) => cb(instance, event));\n\t}, { instance });\n\n\t// onOpen event\n\tinstance.interceptor.registerOnWSOpen((options, config, event) => {\n\t\tinstance._reconnectionCount = 0;\n\t\tinstance._nextReconnectionDelay = 0;\n\t\tif (instance.connection && instance.connection.implname === \"wsConnector\") {\n\t\t\tinstance.state = event.target.readyState;\n\t\t\tutils.forEach(instance.eventHooks.onStateChange, (cb) => cb(instance, instance.state));\n\t\t\tinstance.protocol = instance.connection.protocol;\n\t\t\tinstance.extensions = instance.connection.extensions;\n\t\t}\n\t\tutils.forEach(instance.eventHooks.onOpen, (cb) => cb(instance, event));\n\t}, { instance: instance });\n\n\t// onMessage event\n\tinstance.interceptor.registerOnWSMessage((options, config, event) => {\n\t\tlet data;\n\t\tlet sanitizedData;\n\t\tlet cachedState = instance.state;\n\t\tlet implName = instance.connectionImplName;\n\n\t\tinstance.state = 6;\n\t\tutils.forEach(instance.eventHooks.onStateChange, (cb) => cb(instance, instance.state));\n\t\tif (implName === \"wsConnector\") {\n\t\t\tdata = event.data;\n\t\t}\n\t\tswitch (instance.protocol.toLowerCase()) {\n\t\t\tcase \"json\":\n\t\t\t\tsanitizedData = JSON.parse(data);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsanitizedData = data;\n\t\t\t\tbreak;\n\t\t}\n\t\t//instance.state = cachedState; // test cached state\n\t\tinstance.state = 1;\n\t\tutils.forEach(instance.eventHooks.onMessage, (cb) => cb(instance, event, sanitizedData));\n\t}, { instance });\n\tinstance.connection = connector(config, instance.interceptor);\n\tinstance.connectionImplName = instance.connection.implname;\n\n\treturn instance;\n};\n\nKyofuucWS.prototype.connection = function connection() {\n\treturn this.connection;\n};\n\nKyofuucWS.prototype.close = function close() {\n\tthis.state = 2;\n\tthis.connection && this.connection.close();\n};\n\nKyofuucWS.prototype.sendMessage = function sendMessage(message) {\n\tif (!this.connection) return;\n\n\tthis.state = 5;\n\t//console.log(\"PROTOCOL\", this.protocol)\n\tif (utils.isObject(message) && this.protocol.toLowerCase() === \"json\") {\n\t\tmessage = JSON.safeStringify(message);\n\t} else {\n\t\t//message = String(message);\n\t}\n\tthis.connection.send(message);\n\tthis.state = 1;\n};\n\nKyofuucWS.prototype.getBufferedAmount = function getBufferedAmount() {\n\tif (!this.connection) return;\n\tif (this.connectionImplName === \"wsConnector\") {\n\t\treturn this.connection.bufferedAmount;\n\t}\n};\n\nKyofuucWS.prototype.getUrl = function getUrl(config) {\n\tconfig = config || this.wsConfig;\n\tif (!config.url) {\n\t\tthrow new Error(\"Invalid config url provider\");\n\t}\n\tconfig = utils.mergeObject(config, this.httpBaseConfig);\n\treturn utils.buildURL(config.url, config.params, config.paramsSerializer).replace(/^\\?/, '');\n};\n\nKyofuucWS.prototype.getBinaryType = function getBinaryType() {\n\tif (!this.connection) return;\n\tif (this.connectionImplName === \"wsConnector\") {\n\t\treturn this.connection.binaryType;\n\t}\n};\n\nKyofuucWS.prototype.setBinaryType = function setBinaryType(type) {\n\tif (!this.connection) return;\n\tif (this.connectionImplName === \"wsConnector\") {\n\t\tthis.connection.binaryType = type;\n\t}\n};\n\nutils.forEach([ \"onOpen\", \"onMessage\", \"onClose\", \"onError\", \"onStateChange\" ], function forEachWSEvent(event) {\n\tKyofuucWS.prototype[event] = function (eventHook) {\n\t\tthis.eventHooks[event].push(eventHook);\n\t}\n});\n\nKyofuucWS.STATE = {\n\tCONNECTING: 0,\n\tCONNECTED: 1,\n\tREADY: 1,\n\tDISCONNECTING: 2,\n\tDISCONNECTED: 3,\n\tRECONNECTING: 4,\n\tPROCESSIMG_OUTGOING_MESSAGE: 5,\n\tPROCESSIMG_INCOMMING_MESSAGE: 6,\n};\n\nmodule.exports = KyofuucWS;\n","\r\n\r\nmodule.exports = {\r\n    WebSocket,\r\n    http: null,\r\n    https: null,\r\n    XMLHttpRequest,\r\n};\r\n\r\n","\n'use strict';\n\nconst utils = require('../utils');\nconst classes = require('../helpers/node_classes');\n//const FuQueueManager = require('../core/FuQueueManager');\n\nconst maxReconnectOrRetry = 99999;\n\nfunction getDefaultHttpConnector() {\n\tlet connector;\n\tif (typeof XMLHttpRequest !== 'undefined') { \n\t\tconnector = require('../connectors/http/xhrConnector');\n\t} else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {\n\t\tconnector = require('../connectors/http/httpConnector');\n\t}\n\treturn connector;\n}\n\nfunction getDefaultWSConnector() {\n\tlet connector = require('../connectors/ws/wsConnector');\n\treturn connector;\n}\n\nfunction getHttpAgent() {\n\tif (utils.envIsNodeJs() && classes.http) {\n\t\treturn {\n\t\t\thttpAgent: new classes.http.Agent({ keepAlive: true }),\n\t\t\thttpsAgent: new classes.https.Agent({ keepAlive: true }),\n\t\t};\n\t}\n\treturn {};\n}\n\nconst httpConfig = {\n\tconnector: getDefaultHttpConnector(),\n\ttimeout: 0,\n\txsrfCookieName: 'XSRF-TOKEN',\n\txsrfHeaderName: 'X-XSRF-TOKEN',\n\tmaxContentLength: -1,\n\tmaxBodyLength: -1,\n\tmaxRedirects: 5,\n\ttimeout: 5000,\n\tresponseType: \"json\",\n\tvalidateStatus: function validateStatus(status) {\n\t\treturn status >= 200 && status < 300;\n\t},\n\theaders: {\n\t\t'Accept': 'application/json, text/plain, */*'\n\t},\n\tretry: false,\n\tmaxRetry: maxReconnectOrRetry,\n\tonRetryCompleted: null,\n\t...getHttpAgent()\n};\n\nconst wsConfig = {\n\tconnector: getDefaultWSConnector(),\n\tprotocol: [],\n\treconnect: false,\n\tmaxReconnect: maxReconnectOrRetry,\n\treconnectInterval: -1,\n\treconnectIntervalByPower: false\n};\n\n//const fuQueueManager = new FuQueueManager();\n\nmodule.exports = {\n\twsConfig,\n\thttpConfig,\n\tgetHttpAgent,\n\t//fuQueueManager,\n\tmaxReconnectOrRetry,\n\tgetDefaultWSConnector,\n\tgetDefaultHttpConnector\n}\n","\nconst KyofuucHttp = require('./core/KyofuucHttp');\nconst KyofuucWS = require('./core/KyofuucWS');\nconst FuInterceptor = require('./core/FuInterceptor');\nconst FuQueueManager = require('./core/FuQueueManager');\nconst connectors = require('./connectors/index');\nconst cachemanagers = require('./cachemanagers/index');\nconst defaults = require(\"./helpers/defaults\");\nconst utils = require(\"./utils\");\n\nfunction init(config) {\n\tconst queueManager = (config || {}).fuQueueManager || new FuQueueManager();\n\tif (config && config.httpConfig && !config.httpConfig.fuQueueManager) config.httpConfig.fuQueueManager = queueManager;\n\tconst httpConfig = ((config.httpConfig || config) || defaults.httpConfig);\n\tconst wsConfig = ((config.wsConfig || config) || defaults.wsConfig);\n\n\tif (!httpConfig.responseType) httpConfig.responseType = defaults.httpConfig.responseType;\n\tif (!httpConfig.validateStatus) httpConfig.validateStatus = defaults.httpConfig.validateStatus;\n\n\tconst kfHTTP = new KyofuucHttp(httpConfig);\n\tconst kfWS = new KyofuucWS(wsConfig);\n\tkfHTTP.kfWS = kfWS;\n\tkfHTTP.queueManager = queueManager;\n\tkfHTTP.ws = (p1, p2) => kfHTTP.kfWS.ws(p1, p2);\n\treturn kfHTTP;\n\t//return utils.mergeClasses(kfHTTP, kfWS);\n}\n\nfunction retryHttpRequests(queueManager, ffs) {\n\tif (!queueManager) return;\n\tqueueManager.retry(\"KYOFUUC_HTTP_REQUEST\", ffs);\n}\n\nconst ffs = init(defaults.httpConfig);\n\n// add the core classes \nffs.KyofuucWS = KyofuucWS;\nffs.KyofuucHttp = KyofuucHttp;\nffs.FuInterceptor = FuInterceptor;\n\n// add defaults\nffs.defaults = defaults;\n\n// add the utils \nffs.utils = utils;\nffs.init = init;\nffs.retryHttpRequests = retryHttpRequests;\nffs.retryRequests = () => {\n\tretryHttpRequests(ffs.queueManager, ffs);\n};\n\n// add the cache managers \nffs.cachemanagers = cachemanagers;\nffs.connectors = connectors;\n\nmodule.exports = ffs;\nmodule.exports.default = ffs;\n","\n'use strict';\n\nconst VERSION = \"0.0.1\";\n\nconst ERROR_CODES = {\n\tUNKNOWN_ERROR: \"UNKNOWN_ERROR\",\n\tREQUEST_FAILED: \"ERR_REQUEST_FAILED\",\n\tMAXCONTENTLENGTH_EXCEEDED: \"ERR_MAXCONTENTLENGTH_EXCEEDED\",\n\tREQUEST_ABORTED: \"ERR_REQUEST_ABORTED\",\n\tSTREAM_ERROR: \"ERR_STREAM_ERROR\",\n\tERR_PROCESSING_DATA: \"ERR_PROCESSING_DATA\",\n\tERR_PROCESSING_BODY_AS_JSON_DATA: \"ERR_PROCESSING_BODY_AS_JSON_DATA\",\n\tMAX_REDIRECT_ERROR: \"MAX_REDIRECT_ERROR\",\n\tCONNECTION_ABORTED: \"ECONNABORTED\",\n\tNETWORK_ERROR: \"NETWORK_ERROR\",\n\tTIMEOUT_ERROR: \"TIMEOUT_ERROR\"\n};\n\nconst GLOBAL_EVENT_NAMES = {\n\tRETRY_MAXED_OUT: \"FQM_RETRY_MAXED_OUT\",\n\tRETRY_SUCCESS: \"FQM_RETRY_SUCCESS\",\n\tRETRY_FAILED: \"FQM_RETRY_FAILED\",\n\tEVENT_QUEUED: \"FQM_EVENT_QUEUED\"\n}\n\nconst _globalEvents = {};\n\nJSON.safeStringify = (obj, indent = 2) => {\n\tlet cache = [];\n\tconst retVal = JSON.stringify(\n\t  obj,\n\t  (key, value) =>\n\t\ttypeof value === \"object\" && value !== null\n\t\t  ? cache.includes(value)\n\t\t\t? \"[Circular]\" // Duplicate reference found, discard key\n\t\t\t: cache.push(value) && value // Store value in our collection\n\t\t  : value,\n\t  indent\n\t);\n\tcache = null;\n\treturn retVal;\n};\n\nfunction isString(val) {\n\treturn typeof val === 'string';\n}\n\nfunction isArray(val) {\n\treturn Array.isArray(val);\n}\n\nfunction isFormData(val) {\n\treturn toString.call(val) === '[object FormData]';\n}\n\nfunction isObject(val) {\n\treturn val !== null && typeof val === 'object';\n}\n\nfunction isNumber(val) {\n\treturn typeof val === 'number';\n}\n\nfunction isPlainObject(val) {\n\tif (toString.call(val) !== '[object Object]') {\n\t\treturn false;\n\t}\n  \n\tlet prototype = Object.getPrototypeOf(val);\n\treturn prototype === null || prototype === Object.prototype;\n}\n\nfunction isFunction(val) {\n\treturn toString.call(val) === '[object Function]';\n}\n\nfunction isDate(val) {\n\treturn toString.call(val) === '[object Date]';\n}\n\nfunction isStream(val) {\n\treturn isObject(val) && isFunction(val.pipe);\n}\n\nfunction isArrayBuffer(val) {\n\treturn toString.call(val) === '[object ArrayBuffer]';\n}\n\nfunction isUndefined(val) {\n\treturn typeof val === 'undefined';\n}\n\nfunction stripBOM(content) {\n\tif (content.charCodeAt(0) === 0xFEFF) {\n\t\tcontent = content.slice(1);\n\t}\n\treturn content;\n}\n\nfunction forEach(obj, fn) {\n\tif (obj === null || typeof obj === 'undefined') {\n\t\treturn;\n\t}\n\tif (typeof obj !== 'object') {\n\t\tobj = [obj];\n\t}\n  \n\tif (isArray(obj)) {\n\t\tfor (var i = 0, l = obj.length; i < l; i++) {\n\t\t\tfn.call(null, obj[i], i, obj);\n\t\t}\n\t} else {\n\t\tfor (var key in obj) {\n\t\t\tif (Object.prototype.hasOwnProperty.call(obj, key)) {\n\t\t\t  fn.call(null, obj[key], key, obj);\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction mergeObject(obj1, obj2) {\n\tobj1 = obj1 || {};\n\tobj2 = obj2 || {};\n\tif ((obj1 === null || typeof obj1 === 'undefined') && \n\t\t(obj2 === null || typeof obj2 === 'undefined')) {\n\t\treturn {};\n\t}\n\tlet merged = {};\n\tif (typeof obj1 !== 'object' && typeof obj2 === 'object') {\n\t\tmerged = obj2;\n\t\treturn merged;\n\t}\n\tif (typeof obj2 !== 'object') {\n\t\tmerged = obj1;\n\t\treturn merged;\n\t}\n\tfor (var key in obj1) { merged[key] = obj1[key]; }\n\tfor (var key in obj2) {\n\t\tif (merged[key] === undefined || merged[key] === null) {\n\t\t\tmerged[key] = obj2[key];\n\t\t}\n\t}\n\treturn merged;\n}\n\nfunction invokeForEachInterceptorType(interceptor, type, config, res) {\n\tconst responses = [];\n\tif (!interceptor) return responses;\n\tforEach(interceptor.filter(h => h && h.type === type), function iterateHandler(handler) {\n\t\tif (!handler || !handler.cb) return;\n\t\tif (typeof handler.when === 'function' && handler.when(config) === false) return;\n\t\tconst response = handler.cb(handler.options, config, res);\n\t\tif (response !== undefined) responses.push(response);\n\t});\n\treturn responses;\n}\n\nfunction isURLSearchParams(val) {\n\treturn toString.call(val) === '[object URLSearchParams]';\n}\n\nfunction encodeParamURI(val) {\n\treturn encodeURIComponent(val).\n\t\treplace(/%5B/gi, '[').\n\t\treplace(/%5D/gi, ']').\n\t\treplace(/%3A/gi, ':').\n\t\treplace(/%24/g, '$').\n\t\treplace(/%20/g, '+').\n\t\treplace(/%2C/gi, ',');\n}\n\nfunction buildURL(url, params, serializer) {\n\tif (!params) {\n\t\treturn url;\n\t}\n\n\tlet formatedParams;\n\tif (isURLSearchParams(params)) {\n\t\tformatedParams = params.toString();\n\t} else if (serializer) {\n\t\tformatedParams = serializer(params);\n\t} else {\n\t\tlet paramsParts = [];\n\t\tforEach(params, function serialize(value, key) {\n\t\t\tif (value === null || typeof value === 'undefined') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (isArray(value)) {\n\t\t\t\tkey = key + '[]';\n\t\t\t} else {\n\t\t\t\tvalue = [value];\n\t\t\t}\n\t\t\n\t\t\tforEach(value, function parseValue(val) {\n\t\t\t\tif (isDate(val)) {\n\t\t\t\t\tval = val.toISOString();\n\t\t\t\t} else if (isObject(val)) {\n\t\t\t\t\tval = JSON.stringify(val);\n\t\t\t\t}\n\t\t\t\tparamsParts.push(`${encodeParamURI(key)}=${encodeParamURI(val)}`);\n\t\t\t});\n\t\t\tformatedParams = paramsParts.join('&');\n\t\t});\n\n\t}\n\n\tif (formatedParams) {\n\t\tvar hashIndex = url.indexOf('#');\n\t\tif (hashIndex !== -1) {\n\t\t\turl = url.slice(0, hashIndex);\n\t\t}\n\n\t\turl += (url.indexOf('?') === -1 ? '?' : '&') + formatedParams;\n\t}\n\treturn url;\n}\n\nfunction envIsBrowser() {\n\treturn !(typeof window === 'undefined');\n}\n\nfunction envIsNodeJs() {\n\treturn (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]');\n}\n\nfunction envIsStandardBrowser() {\n\tif (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||\n\t\t\tnavigator.product === 'NativeScript' ||\n\t\t\tnavigator.product === 'NS')) {\n\t  return false;\n\t}\n\treturn (typeof window !== 'undefined' && typeof document !== 'undefined');\n}\n\nfunction kyofuucError(message, config, code, request, response) {\n\tlet error = isString(message) ? new Error(message) : message;\n\terror.config = config;\n\tif (code) {\n\t\terror.code = code;\n\t}\n\terror.request = request;\n\terror.response = response;\n\terror.isKyofuucError = true;\n\t\n\terror.toJSON = function toJSON() {\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tmessage: this.message,\n\t\t\tdescription: this.description,\n\t\t\tnumber: this.number,\n\t\t\tfileName: this.fileName,\n\t\t\tlineNumber: this.lineNumber,\n\t\t\tcolumnNumber: this.columnNumber,\n\t\t\tstack: this.stack,\n\t\t\tconfig: this.config,\n\t\t\tcode: this.code,\n\t\t\tstatus: (this.response && this.response.status ? this.response.status : null),\n\t\t\tresponseBody: (this.response && this.response.body ? this.response.body : null)\n\t\t};\n\t};\n\treturn error;\n}\n\nfunction isAbsoluteURL(url) {\n\treturn /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(url);\n}\n\nfunction isRelativeURL(url) {\n\treturn !isAbsoluteURL(url);\n}\n\nfunction combineURLs(baseURL, relativeURL) {\n\treturn relativeURL\n\t\t? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n\t\t: baseURL;\n}\n\nfunction buildFullURLPath(baseURL, requestURL) {\n\tif (baseURL && !isAbsoluteURL(requestURL)) {\n\t\treturn combineURLs(baseURL, requestURL);\n\t}\n\treturn requestURL;\n}\n\nfunction mergeClassPrototypes(baseClazz, joinClazz) {\n\tforEach(joinClazz.constructor.prototype || [], function iterateDecl(methodDecl, methodName) {\n\t\tif (!(methodName in baseClazz.constructor.prototype)) {\n\t\t\tbaseClazz.constructor.prototype[methodName] = methodDecl;\n\t\t}\n\t});\n}\n\nfunction mergeClassAttribute(baseClazz, joinClazz) {\n\tforEach(joinClazz || {}, function iterateDecl(attribute, name) {\n\t\tlet oldValue = baseClazz[name];\n\t\tif (oldValue) {\n\t\t\tif (isObject(oldValue)) {\n\t\t\t\tbaseClazz[name] = mergeObject(oldValue, attribute);\n\t\t\t} else if (isArray(oldValue)) {\n\n\t\t\t}\n\t\t} else {\n\t\t\tbaseClazz[name] = attribute;\n\t\t}\n\t})\n}\n\nfunction mergeClasses(...classes) {\n\tconst baseClazz = classes[0];\n\tforEach(classes, function iterateClass(clazz, index) {\n\t\tif (index == 0) return;\n\t\tmergeClassAttribute(baseClazz, clazz);\n\t\tmergeClassPrototypes(baseClazz, clazz);\n\t});\n\treturn baseClazz;\n}\n\nfunction resolveResponse(response, resolve, reject) {\n\tlet validateStatus = response.config.validateStatus;\n\tif (!response.status || !validateStatus || validateStatus(response.status)) {\n\t\tresolve(response);\n\t} else {\n\t\treject(kyofuucError(\n\t\t\t'Request failed with status code ' + response.status,\n\t\t\tresponse.config,\n\t\t\tERROR_CODES.REQUEST_FAILED,\n\t\t\tresponse.request,\n\t\t\tresponse\n\t\t));\n\t}\n}\n\nfunction buildCacheKey(config) {\n\treturn config.key || config.url + (config.isResource \n\t\t? `_${(config.method || \"GET\").toUpperCase()}_RESOURCE` \n\t\t: `_${(config.method || \"GET\").toUpperCase()}_SINGLE`);\n}\n\nlet ignoreDuplicateOf = [\n\t'age', 'authorization', 'content-length', 'content-type', 'etag',\n\t'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\n\t'last-modified', 'location', 'max-forwards', 'proxy-authorization',\n\t'referer', 'retry-after', 'user-agent'\n];\n\nfunction trim(str) {\n\treturn str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, '');\n}\n\nfunction parseHeaders(headers) {\n\tvar parsed = {};\n\tvar key;\n\tvar val;\n\tvar i;\n  \n\tif (!headers) { return parsed; }\n  \n\tforEach(headers.split('\\n'), function parser(line) {\n\t  i = line.indexOf(':');\n\t  key = trim(line.substr(0, i)).toLowerCase();\n\t  val = trim(line.substr(i + 1));\n  \n\t  if (key) {\n\t\tif (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {\n\t\t  return;\n\t\t}\n\t\tif (key === 'set-cookie') {\n\t\t  parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);\n\t\t} else {\n\t\t  parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n\t\t}\n\t  }\n\t});\n  \n\treturn parsed;\n};\n\nfunction toBase64(value) {\n\tif (envIsBrowser()) {\n\t\treturn btoa(value);\n\t}\n\treturn Buffer.from(value).toString('base64');\n}\n\nfunction fromBase64(value) {\n\tif (envIsBrowser()) {\n\t\treturn atob(value);\n\t}\n\treturn Buffer.from(value, 'base64').toString();\n}\n\nfunction isURLSameOrigin(url) {\n\treturn false;\n}\n\nfunction presentElseImport(item, actual, fallback) {\n\tif (item !== \"undefined\") return actual.call();\n\telse return fallback.call();\n}\n\nfunction cloneInstance(instance) {\n\treturn Object.assign(Object.create(Object.getPrototypeOf(instance)), instance);\n}\n\n// global event listeners\n\nfunction registerGlobalEvent(key, event) {\n\tif (!_globalEvents[key]) _globalEvents[key] = [];\n\t_globalEvents[key].push(event);\n\treturn _globalEvents.length - 1;\n}\n\nfunction unRegisterGlobalEvent(key, index) {\n\tif (!_globalEvents[key] || !_globalEvents[key].length) return;\n\t_globalEvents[key].splice(index, 1);\n}\n\nfunction getGlobalEvent(key) {\n\treturn _globalEvents[key] || [];\n}\n\nconst registerQueuedEvent = (event) => registerGlobalEvent(GLOBAL_EVENT_NAMES.EVENT_QUEUED, event);\nconst registerRetryFailureEvent = (event) => registerGlobalEvent(GLOBAL_EVENT_NAMES.RETRY_FAILED, event);\nconst registerRetrySuccessEvent = (event) => registerGlobalEvent(GLOBAL_EVENT_NAMES.RETRY_SUCCESS, event);\nconst registerRetryMaxedOutEvent = (event) => registerGlobalEvent(GLOBAL_EVENT_NAMES.RETRY_MAXED_OUT, event);\n\nmodule.exports = {\n\ttrim,\n\tisDate,\n\tVERSION,\n\tforEach,\n\tisArray,\n\ttoBase64,\n\tstripBOM,\n\tbuildURL,\n\tisNumber,\n\tisStream,\n\tisString,\n\tisObject,\n\tfromBase64,\n\tisFormData,\n\tisFunction,\n\tenvIsNodeJs,\n\tmergeObject,\n\tcombineURLs,\n\tERROR_CODES,\n\tisUndefined,\n\tmergeClasses,\n\tenvIsBrowser,\n\tparseHeaders,\n\tkyofuucError,\n\tisPlainObject,\n\tisAbsoluteURL,\n\tisRelativeURL,\n\tisArrayBuffer,\n\tbuildCacheKey,\n\tcloneInstance,\n\tencodeParamURI,\n\tgetGlobalEvent,\n\tisURLSameOrigin,\n\tresolveResponse,\n\tbuildFullURLPath,\n\tisURLSearchParams,\n\tpresentElseImport,\n\tGLOBAL_EVENT_NAMES,\n\tregisterQueuedEvent,\n\tregisterGlobalEvent,\n\tmergeClassAttribute,\n\tmergeClassPrototypes,\n\tenvIsStandardBrowser,\n\tunRegisterGlobalEvent,\n\tregisterRetrySuccessEvent,\n\tregisterRetryFailureEvent,\n\tregisterRetryMaxedOutEvent,\n\tinvokeForEachInterceptorType\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","","// startup\n// Load entry module and return exports\n// This entry module used 'module' so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./index.js\");\n",""],"names":[],"sourceRoot":""}